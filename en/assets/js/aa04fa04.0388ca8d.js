"use strict";(self.webpackChunkrm_controls_tutorial=self.webpackChunkrm_controls_tutorial||[]).push([[953],{3905:function(e,t,a){a.d(t,{Zo:function(){return c},kt:function(){return m}});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var p=n.createContext({}),s=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},c=function(e){var t=s(e.components);return n.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,l=e.originalType,p=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=s(a),m=i,h=d["".concat(p,".").concat(m)]||d[m]||u[m]||l;return a?n.createElement(h,r(r({ref:t},c),{},{components:a})):n.createElement(h,r({ref:t},c))}));function m(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=a.length,r=new Array(l);r[0]=d;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:i,r[1]=o;for(var s=2;s<l;s++)r[s]=a[s];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},8630:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return o},contentTitle:function(){return p},metadata:function(){return s},toc:function(){return c},default:function(){return d}});var n=a(7462),i=a(3366),l=(a(7294),a(3905)),r=["components"],o={},p="Introduction",s={unversionedId:"digging_deeper/theory/bullet_solver",id:"digging_deeper/theory/bullet_solver",isDocsHomePage:!1,title:"Introduction",description:"In practice, the target to be hit tends to move, and the bullet will be dragged in the air and the launch of the barrel will be delayed. We need to make a barrel angle solver to predict the firing angle of the barrel to achieve more accurate strikes.",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/digging_deeper/theory/bullet_solver.md",sourceDirName:"digging_deeper/theory",slug:"/digging_deeper/theory/bullet_solver",permalink:"/test-docs/en/docs/digging_deeper/theory/bullet_solver",editUrl:"https://github.com/rm-controls/rm-controls-tutorial/current_docs/digging_deeper/theory/bullet_solver.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"armor_kalman_filter",permalink:"/test-docs/en/docs/digging_deeper/theory/armor_kalman_filter"},next:{title:"imu_ptz_control",permalink:"/test-docs/en/docs/digging_deeper/theory/imu_ptz_control"}},c=[{value:"Base class",id:"base-class",children:[]},{value:"Bullet motion model",id:"bullet-motion-model",children:[]},{value:"Target point motion model",id:"target-point-motion-model",children:[]},{value:"Include header file",id:"include-header-file",children:[]},{value:"Create class object",id:"create-class-object",children:[]},{value:"Set parameters",id:"set-parameters",children:[]},{value:"Calculate and output the launch angle",id:"calculate-and-output-the-launch-angle",children:[]}],u={toc:c};function d(e){var t=e.components,a=(0,i.Z)(e,r);return(0,l.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"introduction"},"Introduction"),(0,l.kt)("p",null,"In practice, the target to be hit tends to move, and the bullet will be dragged in the air and the launch of the barrel will be delayed. We need to make a barrel angle solver to predict the firing angle of the barrel to achieve more accurate strikes."),(0,l.kt)("p",null,"Purpose:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Consider air resistance (proportional to speed)"),(0,l.kt)("li",{parentName:"ul"},"Consider target speed"),(0,l.kt)("li",{parentName:"ul"},"Consider the launch delay")),(0,l.kt)("p",null,"Difficulties:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"No analytical solution"),(0,l.kt)("li",{parentName:"ul"},"The target solution frequency is greater than 1Khz")),(0,l.kt)("p",null,"Two algorithms:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Iterative method:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Advantages: higher accuracy (when there are many iterations)"),(0,l.kt)("li",{parentName:"ul"},"Disadvantages: slow"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Velocity stacking method:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Advantages: fast speed (within 20us)"),(0,l.kt)("li",{parentName:"ul"},"Disadvantages: inherent error",(0,l.kt)("br",null)))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Algorithm block diagram:\n",(0,l.kt)("img",{parentName:"p",src:"https://s1.ax1x.com/2020/10/24/BVZR9P.png",alt:"BVZR9P.png"})))),(0,l.kt)("h1",{id:"model-derivation"},"Model derivation"),(0,l.kt)("p",null,"Air resistance is proportional to speed, and the target point moves at a constant speed.\n2D Model: In the xz plane, assuming that the bullet launching point is the coordinate origin, the actual position of the bullet is equivalent to a vector in the xoz plane.\n",(0,l.kt)("img",{parentName:"p",src:"https://s1.ax1x.com/2020/10/23/BEgFbT.png",alt:"BEgFbT.png"}),"\nUse to represent the component of the bullet position vector in the X direction, $\\vec{v",(0,l.kt)("em",{parentName:"p"},"x}, \\vec{v_z}$ represent the component of the bullet velocity on the x axis and z axis, respectively,and use $\\vec{z}$ to represent the component of the bullet position vector in the z direction; $v_0$ represents the initial launch velocity of the bullet, k is the air resistance coefficient, g is the acceleration of gravity, m is the weight of the bullet, and $f_x$ is the position of the bullet. The component of air resistance in the X direction.Based on physical knowledge:\n$$\\vec{f_x}=-k\\vec{v_x}=m\\frac{d\\vec{v_x}}{dt}\\tag{1}$$\nSort (1) to get:\n$$-\\frac kmdt=\\frac{d\\vec{v_x}}{v_x}$$\nTaking the time of bullet launching as time 0, the component of the initial launch velocity in the x direction is $\\vec{v_x}$, Integrate the above formula:\n$$\\int_0^t-\\frac kmdt=\\int"),"{v",(0,l.kt)("em",{parentName:"p"},"{x_0}}^{v_x}\\frac{dv_x}{v_x}\\tag{2}$$\nSolved by (2):\n$$v_x=\\frac{dx}{dt}=v"),"{x",(0,l.kt)("em",{parentName:"p"},"0}e^{-\\frac kmt}$$\nIntegrate both sides of the above formula to obtain:\n$$x=\\frac mk v"),"{x",(0,l.kt)("em",{parentName:"p"},"0}(1-e^{-\\frac kmt})\\tag{3}$$\nAt the same time, the resistance of the bullet in the z-axis direction can be obtained as:\n$$\\vec{f_z}=-k\\vec{v_z}-mg=m\\frac{d\\vec{v_z}}{dt}$$\nSort out the differential equation:\n$$\\frac{dv_z}{dt}+\\frac kmv_z+g=0\\tag{4}$$\nSolutions have to:\n$$z=\\frac km\\left(v"),"{z",(0,l.kt)("em",{parentName:"p"},"0}+\\frac{mg}k\\right)\\left(1-e^{-\\frac kmt}\\right)-\\frac{mg}kt\\tag{5}$$\nTarget point motion model: Suppose the starting position of the target point is $\\left(x"),"{t",(0,l.kt)("em",{parentName:"p"},"0}, z"),"{t",(0,l.kt)("em",{parentName:"p"},"0}\\right)$, The speed of the target point in the x-axis direction is $v"),"{t",(0,l.kt)("em",{parentName:"p"},"x}$, the speed in the z-axis direction is $v"),"{t",(0,l.kt)("em",{parentName:"p"},"z}$, the component of the actual position of the target point in the x-axis direction is $x_t$, in the z-axis The component of the direction is $z_t$.\n$$x_t=x"),"{t",(0,l.kt)("em",{parentName:"p"},"0}+v"),"{t",(0,l.kt)("em",{parentName:"p"},"x}t","\\","z_t=z"),"{t",(0,l.kt)("em",{parentName:"p"},"0}+v"),"{t",(0,l.kt)("em",{parentName:"p"},"z}t$$\nBased on the derivation of the above 2D model, use y to represent the component of the bullet position vector in the y-axis direction, $v"),"{y",(0,l.kt)("em",{parentName:"p"},"0}$ represents the component of $v_0$ in the y-axis direction; the actual position of the target point in the y-axis direction component is $y_t $, the y-axis coordinate of the starting position is $y"),"{t",(0,l.kt)("em",{parentName:"p"},"0}$, and the speed in the y-axis direction is $v"),"{t",(0,l.kt)("em",{parentName:"p"},"y}$, the movement model of the bullet and the target point in the y direction under the 3D model can be obtained:\n$$ y = \\frac mkv"),"{y",(0,l.kt)("em",{parentName:"p"},"0}(1-e^{-\\frac kmt})$$ $$ y_t = y"),"{t",(0,l.kt)("em",{parentName:"p"},"0} + v"),"{t_y}t$$"),(0,l.kt)("h1",{id:"code"},"Code"),(0,l.kt)("h2",{id:"base-class"},"Base class"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename T>\nclass BulletSolver {\n public:\n  BulletSolver(T resistance_coff, T g, T delay, T dt, T timeout) :\n      resistance_coff_(resistance_coff),\n      dt_(dt), g_(g), delay_(delay),\n      timeout_(timeout) {};\n  virtual ~BulletSolver() = default;\n  virtual void setTarget(const T *pos, const T *vel) = 0;\n  virtual void setBulletSpeed(T speed) { bullet_speed_ = speed; };\n  virtual void solve(const T *angle_init) = 0;\n  virtual void output(T *angle_solved) = 0;\n protected:\n  T bullet_speed_{};\n  T resistance_coff_, g_, dt_, timeout_, delay_;\n};\n")),(0,l.kt)("p",null,"The BulletSolver class is the base class of all models and algorithms. It defines the algorithm function interface for solving the bullet launch angle, and member variables such as air drag coefficient, gravitational acceleration, launch delay, and bullet velocity."),(0,l.kt)("h4",{id:"function-description"},"Function description"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"setTarget() "),(0,l.kt)("p",{parentName:"li"}," Set the target point, used to initialize the initial position and speed of the target point")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"setBulletSpeed() "),(0,l.kt)("p",{parentName:"li"}," Set bullet speed, used to initialize bullet launch speed")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"solve()"),(0,l.kt)("p",{parentName:"li"}," Calculation, used to calculate the final barrel angle")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"output()"),(0,l.kt)("p",{parentName:"li"}," Output, used to output the final barrel angle"))),(0,l.kt)("h4",{id:"variable-description"},"Variable description"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"bullet",(0,l.kt)("em",{parentName:"p"},"speed"),"(",(0,l.kt)("inlineCode",{parentName:"p"},"T"),")"),(0,l.kt)("p",{parentName:"li"}," Initial bullet velocity")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"resistance",(0,l.kt)("em",{parentName:"p"},"coff")),(0,l.kt)("p",{parentName:"li"}," Coefficient of air resistance")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"g_"),(0,l.kt)("p",{parentName:"li"}," Acceleration of gravity")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"dt_"),(0,l.kt)("p",{parentName:"li"}," Loop iteration interval")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"timeout_"),(0,l.kt)("p",{parentName:"li"}," The condition to exit the loop, when the calculated time of the bullet flying in the air exceeds this value, it will exit the loop")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"delay_"),(0,l.kt)("p",{parentName:"li"}," Barrel launch delay"))),(0,l.kt)("h2",{id:"bullet-motion-model"},"Bullet motion model"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"rt_bullet_rho = (1 / this->resistance_coff_) * bullet_v_rho\n        * (1 - std::exp(-this->fly_time_ * this->resistance_coff_));\n\nrt_bullet_z = (1 / this->resistance_coff_)\n      * (bullet_v_z + this->g_ / this->resistance_coff_)\n      * (1 - std::exp(-this->fly_time_ * this->resistance_coff_))\n      - this->fly_time_ * this->g_ / this->resistance_coff_;        \n")),(0,l.kt)("h4",{id:"variable-description-1"},"Variable description"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"bullet_v_rho(",(0,l.kt)("inlineCode",{parentName:"p"},"T"),")"),(0,l.kt)("p",{parentName:"li"}," The superposition of bullet velocity $v_x$ and $v_y$")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"rt_bullet_rho"),(0,l.kt)("p",{parentName:"li"}," The actual position of the bullet is superimposed on the x-axis component and the y-axis component")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"rt_bullet_z"),(0,l.kt)("p",{parentName:"li"}," The actual position of the bullet is on the z-axis component")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"fly",(0,l.kt)("em",{parentName:"p"},"time")),(0,l.kt)("p",{parentName:"li"}," Bullet flight time"))),(0,l.kt)("h2",{id:"target-point-motion-model"},"Target point motion model"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"rt_target_x += this->target_dx_ * this->dt_;\nrt_target_y += this->target_dy_ * this->dt_;\n")),(0,l.kt)("h4",{id:"variable-description-2"},"Variable description"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"rt_target_x(",(0,l.kt)("inlineCode",{parentName:"p"},"T"),")"),(0,l.kt)("p",{parentName:"li"}," The actual position of the target point on the x-axis component")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"rt_target_y"),(0,l.kt)("p",{parentName:"li"}," The actual position of the target point on the y-axis component")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"target",(0,l.kt)("em",{parentName:"p"},"dx")),(0,l.kt)("p",{parentName:"li"}," The target point velocity on the x axis component")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"target",(0,l.kt)("em",{parentName:"p"},"dy")),(0,l.kt)("p",{parentName:"li"}," The target point velocity on the y-axis component"))),(0,l.kt)("p",null,"Please refer to the ","[bullet_solver.cpp]"," for the specific implementation of all algorithms."),(0,l.kt)("h1",{id:"test-program"},"Test program"),(0,l.kt)("h2",{id:"include-header-file"},"Include header file"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n#include "bullet_solver.h"\n')),(0,l.kt)("p",null,"The header file contains the definitions of all classes and functions."),(0,l.kt)("h2",{id:"create-class-object"},"Create class object"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"int main(int argc, char **argv) {\n  Iter2DSolver<double> iter2d(0.1, 9.8, 0.01, 0.0001, 3.);\n  Approx2DSolver<double> approx2d(0.1, 9.8, 0.01, 0.01, 3.);\n  Iter3DSolver<double> iter3d(0.1, 9.8, 0.01, 0.0001, 3.);\n  Approx3DSolver<double> approx3d(0.1, 9.8, 0.01, 0.0001, 3.);\n")),(0,l.kt)("h4",{id:"variable-description-3"},"Variable description"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"iter2d(",(0,l.kt)("inlineCode",{parentName:"p"},"Iter2DSolver"),")"),(0,l.kt)("p",{parentName:"li"}," Object instance of iterative algorithm class of 2D model")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"approx2d(",(0,l.kt)("inlineCode",{parentName:"p"},"Approx2DSolver"),")"),(0,l.kt)("p",{parentName:"li"}," An instance of the velocity superposition algorithm class object of the 2D model")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"iter3d(",(0,l.kt)("inlineCode",{parentName:"p"},"Iter3DSolver"),")"),(0,l.kt)("p",{parentName:"li"}," The iterative algorithm class object instance of 3D model")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"approx3d(",(0,l.kt)("inlineCode",{parentName:"p"},"Approx3DSolver"),")"),(0,l.kt)("p",{parentName:"li"}," 3D model speed superposition algorithm class object instance"))),(0,l.kt)("h2",{id:"set-parameters"},"Set parameters"),(0,l.kt)("p",null,"Take the iterative algorithm of the 3D model as an example"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"  double angle_init[2]{}, angle_solved[2]{};\n  double bullet_speed = 18.;\n  double pos_3d[3] = {7, 0, 1};\n  double vel_3d[3] = {0, 1, 0};\n  iter3d.setBulletSpeed(bullet_speed);\n  iter3d.setTarget(pos_3d, vel_3d);\n")),(0,l.kt)("h4",{id:"parameter-description"},"Parameter Description"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"angle_init(",(0,l.kt)("inlineCode",{parentName:"p"},"double"),")"),(0,l.kt)("p",{parentName:"li"}," Customized initial launch angle")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"angle_solved(",(0,l.kt)("inlineCode",{parentName:"p"},"double"),")"),(0,l.kt)("p",{parentName:"li"}," Calculated launch angle")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"bullet_speed(",(0,l.kt)("inlineCode",{parentName:"p"},"double"),")"),(0,l.kt)("p",{parentName:"li"}," Initial velocity of bullet")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"pos_3d(",(0,l.kt)("inlineCode",{parentName:"p"},"double[]"),")"),(0,l.kt)("p",{parentName:"li"}," Initial coordinates of the target point")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"vel_3d(",(0,l.kt)("inlineCode",{parentName:"p"},"double[]"),")"),(0,l.kt)("p",{parentName:"li"}," The speed of the target point in the x, y, z direction"))),(0,l.kt)("h2",{id:"calculate-and-output-the-launch-angle"},"Calculate and output the launch angle"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'  iter3d.solve(angle_init);\n  iter3d.output(angle_solved);\n  std::cout << "yaw:" << angle_solved[0] << " pitch:" << angle_solved[1] << std::endl;\n')))}d.isMDXComponent=!0}}]);